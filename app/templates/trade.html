<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Trade Panel (Ostium)</title>
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <style>
    body { margin:0; padding:20px; background:#070a0f; color:#e7ecf4; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    .box { background:#0c111a; border:1px solid rgba(255,255,255,0.12); border-radius:14px; padding:14px; margin:12px 0; }
    button { background:#0bf673; border:none; padding:10px 12px; border-radius:12px; font-weight:900; cursor:pointer; }
    button.secondary { background:transparent; border:1px solid rgba(255,255,255,0.2); color:#fff; }
    input, select { width:100%; padding:10px; border-radius:12px; border:1px solid rgba(255,255,255,0.14); background:#0a0f16; color:#fff; }
    .row { display:grid; gap:10px; grid-template-columns: 1fr 1fr; }
    pre { white-space: pre-wrap; word-break: break-word; background:#0a0f16; padding:12px; border-radius:12px; border:1px solid rgba(255,255,255,0.08); }
    a { color:#8ea0ff; }
  </style>
</head>
<body>

  <h1>Trade Panel (Ostium)</h1>

  <div class="box">
    <button id="connectBtn" onclick="connect()">Connect MetaMask</button>
    <button class="secondary" onclick="switchToArb()">Switch to Arbitrum</button>
    <div style="margin-top:10px;">
      Wallet: <span id="addr">—</span><br/>
      Network: <span id="net">—</span>
    </div>
  </div>

  <div class="box">
    <button onclick="loadSignal()">Load latest bot signal</button>
    <div style="margin-top:10px;">Signal:</div>
    <pre id="signalBox">—</pre>
  </div>

  <div class="box">
    <h3>Ostium trade (XAUUSD)</h3>
    <div class="row">
      <div>
        <label>Collateral (USDC)</label>
        <input id="collateral" type="number" value="50" step="0.01" />
      </div>
      <div>
        <label>Leverage (x)</label>
        <input id="lev" type="number" value="5" step="1" min="1" max="200" />
      </div>
    </div>

    <div class="row" style="margin-top:10px;">
      <div>
        <label>TP (optional)</label>
        <input id="tp" type="number" step="0.01" placeholder="e.g. 2100" />
      </div>
      <div>
        <label>SL (optional)</label>
        <input id="sl" type="number" step="0.01" placeholder="e.g. 2050" />
      </div>
    </div>

    <div class="row" style="margin-top:10px;">
      <button onclick="place(true)">Buy / Long</button>
      <button class="secondary" onclick="place(false)">Sell / Short</button>
    </div>

    <div style="margin-top:10px;">
      <div>Logs:</div>
      <pre id="log">—</pre>
    </div>

    <div style="margin-top:10px; opacity:.8;">
      Backend signal endpoint: <a href="/api/signal/latest" target="_blank">/api/signal/latest</a>
    </div>
  </div>

<script>
  const REQUIRED_CHAIN_ID = 42161; // Arbitrum One
  const ARB_HEX = "0xa4b1";
  const ARBITRUM_PARAMS = {
    chainId: ARB_HEX,
    chainName: "Arbitrum One",
    nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: ["https://arb1.arbitrum.io/rpc"],
    blockExplorerUrls: ["https://arbiscan.io"]
  };

  // Ostium
  const OSTIUM_BASE = "https://metadata-backend.ostium.io";
  const PAIRS_STORAGE_ADDRESS   = "0x260E349F643f12797fDc6f8c9d3df211D5577823";
  const TRADING_STORAGE_ADDRESS = "0xccd5891083a8acd2074690f65d3024e7d13d66e7";
  const TRADING_ADDRESS         = "0x6D0bA1f9996DBD8885827e1b2e8f6593e7702411";

  const BUILDER_FEE_PCT_FIXED = 0.0;
  const BUILDER_ADDRESS = "0xa30AE19A759538B66CF56B76ef8Acef4183E8Cb9";

  const TRADING_ABI = [
    "function openTrade((uint256 collateral,uint192 openPrice,uint192 tp,uint192 sl,address trader,uint32 leverage,uint16 pairIndex,uint8 index,bool buy) t,(address builder,uint32 builderFee) bf,uint8 orderType,uint256 slippageP) external"
  ];
  const TRADING_STORAGE_ABI = [
    "function usdc() view returns (address)"
  ];
  const ERC20_ABI = [
    "function decimals() view returns (uint8)",
    "function balanceOf(address) view returns (uint256)",
    "function allowance(address owner,address spender) view returns (uint256)",
    "function approve(address spender,uint256 amount) returns (bool)"
  ];

  let provider, signer, addr;

  function logMsg(s){
    const el = document.getElementById("log");
    el.textContent = (el.textContent === "—" ? "" : el.textContent + "\n") + s;
  }

  async function connect(){
    if(!window.ethereum) { alert("MetaMask not found"); return; }
    await window.ethereum.request({ method:"eth_requestAccounts" });
    provider = new ethers.providers.Web3Provider(window.ethereum, "any");
    signer = provider.getSigner();
    addr = await signer.getAddress();
    document.getElementById("addr").textContent = addr;
    await refreshNet();
    logMsg("Connected.");
  }

  async function refreshNet(){
    const chainId = await provider.send("eth_chainId", []);
    const cid = parseInt(chainId, 16);
    document.getElementById("net").textContent = (cid === REQUIRED_CHAIN_ID) ? "Arbitrum One" : ("Chain " + cid);
  }

  async function switchToArb(){
    if(!window.ethereum) return;
    try{
      await window.ethereum.request({ method:"wallet_switchEthereumChain", params:[{ chainId: ARB_HEX }] });
    }catch(e){
      if(e && e.code === 4902){
        await window.ethereum.request({ method:"wallet_addEthereumChain", params:[ARBITRUM_PARAMS] });
      } else {
        throw e;
      }
    }
    if(provider) await refreshNet();
    logMsg("Switched network.");
  }

  // CORS-safe proxy used in your working page
  function jinaProxy(url){
    const noProto = url.replace(/^https?:\/\//, "");
    return "https://r.jina.ai/http://" + noProto;
  }
  function extractJsonFromText(text){
    const firstObj = text.indexOf("{");
    const firstArr = text.indexOf("[");
    const start = (firstArr !== -1 && (firstObj === -1 || firstArr < firstObj)) ? firstArr : firstObj;
    if(start === -1) throw new Error("No JSON found");
    const endObj = text.lastIndexOf("}");
    const endArr = text.lastIndexOf("]");
    const end = Math.max(endObj, endArr);
    return JSON.parse(text.slice(start, end + 1));
  }
  async function fetchJsonViaProxy(url){
    const r = await fetch(jinaProxy(url), { cache:"no-store" });
    const txt = await r.text();
    return extractJsonFromText(txt);
  }
  async function getOstiumLatestPrice(asset){
    return await fetchJsonViaProxy(`${OSTIUM_BASE}/PricePublish/latest-price?asset=${encodeURIComponent(asset)}`);
  }
  function normalizeOstiumPriceResponse(j){
    const candidates = [j?.price, j?.mid, j?.last, j?.value, j?.data?.price, j?.result?.price];
    for(const c of candidates){
      const n = Number(c);
      if(isFinite(n) && n > 0) return n;
    }
    return null;
  }

  async function loadSignal(){
    const r = await fetch("/api/signal/latest", { cache:"no-store" });
    const j = await r.json();
    document.getElementById("signalBox").textContent = JSON.stringify(j, null, 2);

    // convenience: if risk exists, prefill tp/sl roughly
    const sig = j?.signal;
    if(sig?.risk){
      if(sig.risk.tp) document.getElementById("tp").value = sig.risk.tp;
      if(sig.risk.sl) document.getElementById("sl").value = sig.risk.sl;
    }
    logMsg("Loaded latest signal.");
  }

  function clamp(n,min,max){ return Math.max(min, Math.min(max, n)); }
  function toPrice1e18(p){ return ethers.utils.parseUnits(String(p), 18); }
  function getScaledBuilderFeePct(pct){
    const p = clamp(Number(pct || 0), 0, 0.5);
    return Math.round((p / 100) * 1e6);
  }
  function getScaledSlippagePct(pct){
    const p = clamp(Number(pct || 0), 0.01, 50);
    return Math.round(p * 1e2);
  }

  async function ensureAllowance(usdcAddr, amountBn){
    const usdc = new ethers.Contract(usdcAddr, ERC20_ABI, provider);
    const dec = Number(await usdc.decimals());
    const bal = await usdc.balanceOf(addr);
    if(bal.lt(amountBn)) throw new Error("Insufficient USDC balance.");

    const allowance = await usdc.allowance(addr, TRADING_STORAGE_ADDRESS);
    if(allowance.gte(amountBn)) return;

    logMsg("Approving USDC…");
    const usdcW = new ethers.Contract(usdcAddr, ERC20_ABI, signer);
    const tx = await usdcW.approve(TRADING_STORAGE_ADDRESS, amountBn.mul(105).div(100));
    logMsg("Approve tx: " + tx.hash);
    await tx.wait();
    logMsg("USDC approved.");
  }

  async function place(isLong){
    if(!signer || !provider) { alert("Connect MetaMask first"); return; }
    const chainId = parseInt(await provider.send("eth_chainId", []), 16);
    if(chainId !== REQUIRED_CHAIN_ID) { alert("Switch to Arbitrum first"); return; }

    // XAUUSD only for now
    const ASSET = "XAUUSD";
    const PAIR_INDEX = 0; // <-- if your pairs differ, you can map this later by reading PairsStorage like your big page does

    const collateral = Number(document.getElementById("collateral").value || 0);
    const lev = clamp(Number(document.getElementById("lev").value || 1), 1, 200);

    const tpV = Number((document.getElementById("tp").value || "").trim());
    const slV = Number((document.getElementById("sl").value || "").trim());
    const tp = (isFinite(tpV) && tpV > 0) ? toPrice1e18(tpV) : ethers.BigNumber.from(0);
    const sl = (isFinite(slV) && slV > 0) ? toPrice1e18(slV) : ethers.BigNumber.from(0);

    const storage = new ethers.Contract(TRADING_STORAGE_ADDRESS, TRADING_STORAGE_ABI, provider);
    const usdcAddr = await storage.usdc();

    const usdc = new ethers.Contract(usdcAddr, ERC20_ABI, provider);
    const usdcDec = Number(await usdc.decimals());
    const collateralBn = ethers.utils.parseUnits(String(collateral), usdcDec);

    await ensureAllowance(usdcAddr, collateralBn);

    const pRaw = await getOstiumLatestPrice(ASSET);
    const px = normalizeOstiumPriceResponse(pRaw);
    if(!px) throw new Error("Could not read Ostium latest price.");

    const builderFee = { builder: BUILDER_ADDRESS, builderFee: getScaledBuilderFeePct(BUILDER_FEE_PCT_FIXED) };
    const slippageP = getScaledSlippagePct(0.75);

    const trade = {
      collateral: collateralBn,
      openPrice: toPrice1e18(px),
      tp,
      sl,
      trader: addr,
      leverage: Math.round(lev * 100),
      pairIndex: PAIR_INDEX,
      index: 0,
      buy: !!isLong
    };

    const trading = new ethers.Contract(TRADING_ADDRESS, TRADING_ABI, signer);

    logMsg(`Placing ${isLong ? "LONG" : "SHORT"} @ ${px} …`);
    await trading.callStatic.openTrade(trade, builderFee, 0, slippageP);

    const tx = await trading.openTrade(trade, builderFee, 0, slippageP);
    logMsg("Tx: " + tx.hash);
    await tx.wait();
    logMsg("Confirmed.");
  }
</script>

</body>
</html>
